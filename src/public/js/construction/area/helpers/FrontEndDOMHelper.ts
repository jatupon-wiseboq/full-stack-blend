import {HTMLHelper} from '../../helpers/HTMLHelper';
import {CodeHelper} from '../../helpers/CodeHelper';
import {TextHelper} from '../../helpers/TextHelper';
import {StylesheetHelper} from './StylesheetHelper';
import {Accessories, EditorHelper} from './EditorHelper';
import {WorkspaceHelper} from './WorkspaceHelper';
import {SchemaHelper} from './SchemaHelper';
import {FrontEndReactHelper, DEFAULTS} from '../../helpers/FrontEndReactHelper';
import {CAMEL_OF_EVENTS_DICTIONARY, REQUIRE_FULL_CLOSING_TAGS, CONTAIN_TEXT_CONTENT_TAGS, INHERITING_COMPONENT_RESERVED_ATTRIBUTE_NAMES, INHERITING_COMPONENT_RESERVED_STYLE_NAMES, INHERITING_COMPONENT_RESERVED_STYLE_NAMES_IN_CAMEL, ALL_RESPONSIVE_SIZE_REGEX, ALL_RESPONSIVE_OFFSET_REGEX, FORWARD_PROPS_AND_EVENTS_TO_CHILDREN_CLASS_LIST, DOT_NOTATION_CONSUMABLE_TAG_LIST, DOT_NOTATION_CONSUMABLE_CLASS_LIST, NONE_NATIVE_SUPPORT_OF_CAMEL_OF_EVENTS, FORWARD_STYLE_TO_CHILDREN_CLASS_LIST, ALL_DOCUMENT_SUPPORT_OF_CAMEL_OF_EVENTS} from '../../Constants';

let cachedGenerateCodeForReactRenderMethodElement = null;
let cachedGenerateCodeForReactRenderMethodResults = null;

// This code generator relies on elements in construction area.
// 
var FrontEndDOMHelper = {
  invalidate: function() {
    cachedGenerateCodeForReactRenderMethodElement = null;
    cachedGenerateCodeForReactRenderMethodResults = null;
  },
  generateFrontEndCode: function(body: HTMLElement=document.body, container: HTMLElement=HTMLHelper.getElementByAttributeNameAndValue("internal-fsb-guid", "0")) {
    // Document Level
    // 
    let generatedRenderMethodRootResult = FrontEndDOMHelper.generateCodeForReactRenderMethod(body, container);
    let generatedMergingSectionRootResult = FrontEndDOMHelper.generateCodeForMergingSection(body, container);
    
    let functionDeclarations = generatedMergingSectionRootResult[1];
    let functionBindings = generatedMergingSectionRootResult[0];
    let rootHTML = generatedRenderMethodRootResult[1];
    let rootScript = generatedRenderMethodRootResult[0];
    
    // Generate Scripts
    // SEO: Optimize Score of Google PageSpeed Insights.
    // 
    let executions: string[] = [];
    let lines: string[] = [];
    
    FrontEndDOMHelper.recursiveGenerateCodeForPage(body, container, '    ', executions, lines);
    
    let allReactComponentsScript = lines.join('\n');
    let allReactPrerequisiteScript = executions.join('\n');
    
    let combinedHTMLTags = `${rootHTML}`;
    let combinedMinimalFeatureScripts = 
`class Controller {
  dictionary: {} = {};
  
  ${functionDeclarations}
  
  public register(guid, eventName, functionName, capturing) {
    if (!this.dictionary[guid]) this.dictionary[guid] = {};
    this.dictionary[guid][eventName] = [functionName, capturing];
  }
  public listen(guid) {
    if (this.dictionary[guid]) {
      for (let key in this.dictionary[guid]) {
        if (this.dictionary[guid].hasOwnProperty(key)) {
          const eventName = key;
          const functionName = this.dictionary[guid][key][0];
          const capturing = !!this.dictionary[guid][key][1];
          const element = this.getElementUsingGUID(guid);
          
          element.addEventListener(eventName, this[functionName].bind(this), capturing);
        }
      }
    }
  }
  public getElementUsingGUID(guid) {
    return document.querySelectorAll('[internal-fsb-guid="' + guid + '"]')[0];
  }
}
let controller = new Controller();
${functionBindings}
${rootScript}`;
    let combinedExpandingFeatureScripts = `${allReactPrerequisiteScript}${allReactComponentsScript}`;
    
    let links = HTMLHelper.getElementsByAttribute('internal-fsb-link', body);
    links = links.map(link => link.outerHTML);
    let combinedFontTags = links;
    
    let combinedInlineBodyStyle = HTMLHelper.getAttribute(container.ownerDocument.body, 'style');
    
    return [combinedHTMLTags, combinedMinimalFeatureScripts, combinedExpandingFeatureScripts, combinedFontTags, combinedInlineBodyStyle];
  },
  recursiveGenerateCodeForPage: function(body: HTMLElement, element: HTMLElement, indent: string, executions: string[], lines: string[], isFirstElement: boolean=true) {
    if (HTMLHelper.hasClass(element, 'internal-fsb-accessory')) return;
    
    if (element && element.tagName) {
      if (!isFirstElement && HTMLHelper.getAttribute(element, 'internal-fsb-react-mode') && !HTMLHelper.getAttribute(element, 'internal-fsb-inheriting') && !HTMLHelper.hasClass(element, 'internal-fsb-plug')) {
        let _info = HTMLHelper.getAttributes(element, false);
        
        _info.autoGeneratedCodeForRenderMethod = FrontEndDOMHelper.generateCodeForReactRenderMethod(body, element);
        _info.autoGeneratedCodeForMergingRenderMethod = FrontEndDOMHelper.generateCodeForMergingSection(body, element);
        
        let _code, _mapping;
        [_code, _mapping] = FrontEndReactHelper.generateReactCode(_info);
        
        lines.push(_code);
      }
      
      let children = [...element.childNodes];
      
      children = children.filter(element => [Accessories.cursor.getDOMNode(), Accessories.resizer.getDOMNode(), Accessories.guide.getDOMNode()].indexOf(element) == -1);
      
      for (let child of children) {
        FrontEndDOMHelper.recursiveGenerateCodeForPage(body, child, indent, executions, lines, false);
      }
    }
  },
  generateCodeForReactRenderMethod: function(body: HTMLElement, element: HTMLElement) {
    if (cachedGenerateCodeForReactRenderMethodElement == element && cachedGenerateCodeForReactRenderMethodResults)
      return cachedGenerateCodeForReactRenderMethodResults;
    
    let executions: string[] = [];
    let lines: string[] = [];
    
    if (EditorHelper.hasParentReactComponent(element)) {
    	executions.push(`    TestHelper.identify();`);
      executions.push(`    function ready(a){"loading"!=document.readyState?a(new Event('ready')):document.addEventListener?document.addEventListener("DOMContentLoaded",a):(document.onreadystatechange=function(e){"complete"==document.readyState&&a(e)})};
        `);
      FrontEndDOMHelper.recursiveGenerateCodeForReactRenderMethod(body, element, '      ', executions, lines);
    } else {
      executions.push(`TestHelper.identify();`);
      executions.push(`function ready(a){"loading"!=document.readyState?a(new Event('ready')):document.addEventListener?document.addEventListener("DOMContentLoaded",a):(document.onreadystatechange=function(e){"complete"==document.readyState&&a(e)})};
        `);
      FrontEndDOMHelper.recursiveGenerateCodeForFallbackRendering(body, element, '    ', executions, lines);
    }
    
    cachedGenerateCodeForReactRenderMethodElement = element;
    cachedGenerateCodeForReactRenderMethodResults = ['\n' + executions.join('\n'), '\n' + lines.join('\n')];
    
    return cachedGenerateCodeForReactRenderMethodResults;
  },
  recursiveGenerateCodeForReactRenderMethod: function(body: HTMLElement, element: HTMLElement, indent: string, executions: string[], lines: string[], isFirstElement: boolean=true, cumulatedDotNotation: string="", dotNotationChar: string='i', forwardAttributes: string[]=null, context: any={}) {
    if (HTMLHelper.hasClass(element, 'internal-fsb-accessory')) return;
    if (HTMLHelper.hasClass(element, 'internal-fsb-plug')) return;
    
    if (element) {
      if (!element.tagName) {
        if (element.textContent.trim() != '') {
          if (['style', 'script'].indexOf(element.parentNode.tagName && element.parentNode.tagName.toLowerCase() || null) != -1) {
        		lines[lines.length - 1] += '.';
        		lines.push(indent + element.textContent.split('\n').join('\n' + indent));
        	} else {
        		let textContent = element.textContent;
        		textContent = textContent.replace(/(\@)\{([A-Za-z0-9_]+(\.[A-Za-z0-9_]+)*)\}/g, (match, hash, suffix) => {
        			return `\#{this.getDataFromNotation("${cumulatedDotNotation}${suffix}")}`;
        		});
        		
          	lines.push(indent + '| ' + textContent.split('\n').join('\n' + indent + '| '));
          }
        }
      } else {
        let tag = element.tagName.toLowerCase().replace('ruffle-embed', 'embed');
        if (tag === 'button') tag = 'Button';
        
        let _attributes = HTMLHelper.getAttributes(element, true, {}, false);
        let _props = [];
        let _globalEvents = [];
        let _localEvents = [];
        let classes = '';
        let styles = null;
        let bindingStyles = {};
        let attributes = forwardAttributes && CodeHelper.clone(forwardAttributes) || [];
        let _forwardAttributes = [];
        let isForChildren = false;
        let isReactElement = false;
        let reactMode = null;
        let reactCommand = null;
        let reactNamespace = null;
        let reactClass = null;
        let reactID = null;
        let reactData = null;
        let reactFieldDivision = null;
        let reactFieldDivisionStatement = null;
        let reactAccumulateNotation = null;
        let reactDisplayLogic = null;
        let reactDisplayStatement = null;
        let reactClassComposingInfoClassName = null;
        let reactClassComposingInfoGUID = null;
        let reactClassForPopup = null;
        let inheritingID = null;
        let inheritingAttributes = [];
        let inheritingStyles = [];
        let submitControls = null;
        let submitType = null;
        let submitCrossType = null;
        let realTimeUpdate = null;
        let manipulateInto = null;
        let customEvents = [];
        let isPopup = (HTMLHelper.getAttribute(element, 'internal-fsb-class') == 'Popup');
        
        let consumableTagItem = DOT_NOTATION_CONSUMABLE_TAG_LIST.filter(item => (item[0] == tag))[0];
        let consumableClassItem = DOT_NOTATION_CONSUMABLE_CLASS_LIST.filter(item => (item[0] == HTMLHelper.getAttribute(element, 'internal-fsb-class')))[0];
        let dotNotation = HTMLHelper.getAttribute(HTMLHelper.hasClass(element, 'internal-fsb-element') ?
            element : element.parentNode, 'internal-fsb-react-data');
        let dangerouslySetInnerHTML = false
        
        if (dotNotation) {
          if (consumableTagItem) {
            dangerouslySetInnerHTML = consumableTagItem[1] == 'dangerouslySetInnerHTML';
            
            if (tag == 'input') {
              if (['hidden'].indexOf(HTMLHelper.getAttribute(element, 'type')) != -1) {
                consumableTagItem = CodeHelper.clone(consumableTagItem);
                consumableTagItem[1] = 'value';
              } else if (['radio'].indexOf(HTMLHelper.getAttribute(element, 'type')) != -1) {
                consumableTagItem = CodeHelper.clone(consumableTagItem);
                consumableTagItem[1] = 'defaultChecked';
                consumableTagItem[2] = '{';
                consumableTagItem[3] = ' == \'' + HTMLHelper.getAttribute(element, 'value') + '\'}';
              } else if (['checkbox'].indexOf(HTMLHelper.getAttribute(element, 'type')) != -1) {
                consumableTagItem = CodeHelper.clone(consumableTagItem);
                consumableTagItem[1] = 'defaultChecked';
                consumableTagItem[2] = '{';
                consumableTagItem[3] = ' === true}';
              }
            }
            
            let index = _attributes.findIndex(attribute => (attribute.name == consumableTagItem[1]));
            if (index != -1) {
              _attributes[index].value = consumableTagItem[2] + `___DATA___` + consumableTagItem[3];
            } else {
              _attributes.push({
                name: consumableTagItem[1],
                value: consumableTagItem[2] + `___DATA___` + consumableTagItem[3]
              });
            }
          }
          
          if (consumableClassItem) {
            dangerouslySetInnerHTML = consumableClassItem[1] == 'dangerouslySetInnerHTML';
            
            let index = _attributes.findIndex(attribute => (attribute.name == consumableClassItem[1]));
            if (index != -1) {
              _attributes[index].value = consumableClassItem[2] + `___DATA___` + consumableClassItem[3];
            } else {
              _attributes.push({
                name: consumableClassItem[1],
                value: consumableClassItem[2] + `___DATA___` + consumableClassItem[3]
              });
            }
          }
        }
        
        let innerHTML = HTMLHelper.getAttribute(element, 'internal-fsb-inner-html') || '';
        if (innerHTML.trim() != '') {
          dangerouslySetInnerHTML = true; 
          
          let index = _attributes.findIndex(attribute => (attribute.name == 'dangerouslySetInnerHTML'));
          if (index != -1) {
            _attributes[index].value = `{{__html: ${JSON.stringify(innerHTML)}}}`;
          } else {
            _attributes.push({
              name: 'dangerouslySetInnerHTML',
              value: `{{__html: ${JSON.stringify(innerHTML)}}}`
            });
          }
        }
        
        for (let attribute of _attributes) {
          if (attribute.name.indexOf('internal-fsb-react-style-') == 0 && attribute.value) {
            let bindingName = attribute.name.replace('internal-fsb-react-style-', '');
            let bindingType = attribute.value.split('[')[0];
            let bindingValue = attribute.value.match(/^[A-Z]+\[(.+)\]$/)[1];
            
            if (bindingName === 'background-color') {
              attribute.name = 'internal-fsb-react-style-background-color';
              bindingName = 'background';
            }
            
            switch (bindingType) {
              case 'SETTING':
                bindingStyles[bindingName] = 'Project.Settings.' + bindingValue;
                break;
              case 'PROPERTY':
                bindingStyles[bindingName] = 'this.props.' + bindingValue;
                break;
              case 'STATE':
                bindingStyles[bindingName] = 'this.state.' + bindingValue;
                break;
              case 'CODE':
                bindingStyles[bindingName] = '(()=>{' + bindingValue + '})()';
                break;
            }
          }
        }
        
        if (FORWARD_STYLE_TO_CHILDREN_CLASS_LIST.indexOf(HTMLHelper.getAttribute(element, 'internal-fsb-class')) != -1) {
          bindingStyles['padding'] = bindingStyles['padding'] || "'0px'";
        }
        
        for (let attribute of _attributes) {
        	if (attribute.value === null) continue;
        	
        	attribute.name = CodeHelper.replaceDashIntoCamelCase(attribute.name);
        	
          switch (attribute.name) {
            case 'class':
              classes = attribute.value.replace('internal-fsb-selecting', '').replace('internal-fsb-walking', '').replace('internal-fsb-allow-cursor', '').trim().replace(/[\ ]+/g, ' ');
              
              let sizeMatches = attribute.value.match(ALL_RESPONSIVE_SIZE_REGEX) || [];
              let offsetMatches = attribute.value.match(ALL_RESPONSIVE_OFFSET_REGEX) || [];
              
              inheritingAttributes.push("'classes': '" + [...sizeMatches, ...offsetMatches].join(' ') + "'");
              break;
            case 'style':
              attribute.value = element.getAttribute('style');
              if (attribute.value == '-fsb-empty') {
                continue;
              }
              let hashMap = HTMLHelper.getHashMapFromInlineStyle(attribute.value);
              for (let key in hashMap) {
                if (hashMap.hasOwnProperty(key)) {
                  if (styles == null) styles = [];
                  let camelKey = key.replace(/\-([a-z])/g, (matched) => { return matched[1].toUpperCase(); });
                  if (!camelKey) continue;
                  if (camelKey.indexOf('FsbCell') == 0) continue;
                  if (camelKey.indexOf('FsbForChildren') == 0 && hashMap[key] == 'true') {
                    continue;
                  }
                  
                  if (bindingStyles[key]) {
                    let token = "'" + camelKey + "': " + bindingStyles[key] + " || '" + hashMap[key] + "'";
                    styles.push(token);
                    delete bindingStyles[key];
                  
                    if (isPopup || INHERITING_COMPONENT_RESERVED_STYLE_NAMES.indexOf(key) != -1) {
                      inheritingStyles.push(token);
                    }
                  } else {
                    let token = "'" + camelKey + "': '" + hashMap[key] + "'";
                    styles.push(token);
                  
                    if (isPopup || INHERITING_COMPONENT_RESERVED_STYLE_NAMES.indexOf(key) != -1) {
                      inheritingStyles.push(token);
                    }
                  }
                }
              }
              break;
            case 'internal-fsb-react-mode':
              if (!!attribute.value) reactMode = attribute.value;
              break;
            case 'internal-fsb-react-command':
              if (!!attribute.value) reactCommand = attribute.value;
              break;
            case 'internal-fsb-react-namespace':
              if (!!attribute.value) reactNamespace = attribute.value;
              break;
            case 'internal-fsb-react-class':
              if (!!attribute.value) reactClass = attribute.value;
              break;
            case 'internal-fsb-react-id':
              if (!!attribute.value) reactID = attribute.value;
              break;
            case 'internal-fsb-react-data':
              if (!!attribute.value) reactData = attribute.value;
              break;
            case 'internal-fsb-react-division':
              if (!!attribute.value) reactFieldDivision = attribute.value;
              break;
            case 'internal-fsb-react-division-statement':
              if (!!attribute.value) reactFieldDivisionStatement = attribute.value;
              break;
            case 'internal-fsb-react-accumulate':
              if (!!attribute.value) reactAccumulateNotation = attribute.value;
              break;
            case 'internal-fsb-react-display-logic':
              if (!!attribute.value) reactDisplayLogic = attribute.value;
              break;
            case 'internal-fsb-react-display-statement':
              if (!!attribute.value) reactDisplayStatement = attribute.value;
              break;
            case 'internal-fsb-data-controls':
              if (!!attribute.value) submitControls = attribute.value.trim();
              break;
            case 'internal-fsb-data-wizard-type':
              if (!!attribute.value) submitType = attribute.value;
              break;
            case 'internal-fsb-data-wizard-cross-operation':
              if (!!attribute.value) submitCrossType = attribute.value;
              break;
            case 'internal-fsb-data-wizard-real-time-update':
            	if (!!attribute.value) realTimeUpdate = attribute.value;
            	break;
            case 'internal-fsb-data-wizard-retrieve-into':
            case 'internal-fsb-data-wizard-manipulate-into':
            	if (!!attribute.value) manipulateInto = attribute.value;
            	break;
            case 'internal-fsb-class':
              if (!!attribute.value) reactClassComposingInfoClassName = attribute.value;
              if (['FlowLayout'].indexOf(attribute.value) != -1) _props.push('internal-fsb-class="' + attribute.value + '"');
              break;
            case 'internal-fsb-guid':
              if (!!attribute.value) reactClassComposingInfoGUID = attribute.value;
              break;
            case 'internal-fsb-popup-init-class':
              if (!!attribute.value) reactClassForPopup = attribute.value;
              break;
            case 'internal-fsb-inheriting':
              if (!!attribute.value) inheritingID = attribute.value;
              break;
            case 'contenteditable':
              continue;
            default:
              if (attribute.name.indexOf('internal-fsb-') == 0 && ['internal-fsb-animation', 'internal-fsb-ratio-fit', 'internal-fsb-ratio-expand'].indexOf(attribute.name) == -1) continue;
              if (CAMEL_OF_EVENTS_DICTIONARY[attribute.name]) {
                let value = null;
                if (attribute.value) value = JSON.parse(attribute.value);
                else value = {};
                
                if (value.event) {
                  let FUNCTION_NAME = CAMEL_OF_EVENTS_DICTIONARY[attribute.name].replace(/^on/, 'on' + HTMLHelper.getAttribute(element, 'internal-fsb-class')) + '_' + HTMLHelper.getAttribute(element, 'internal-fsb-guid');
                  
                  if (ALL_DOCUMENT_SUPPORT_OF_CAMEL_OF_EVENTS.indexOf(attribute.name) != -1) {
                  	if (attribute.name == 'onfsbready') {
                    	_globalEvents.push("ready(this." + FUNCTION_NAME + ".bind(this));");
                    } else {
                    	_globalEvents.push("document.addEventListener('" + CAMEL_OF_EVENTS_DICTIONARY[attribute.name].replace(/^on(Document)?/, '').toLowerCase() + "', this." + FUNCTION_NAME + ".bind(this), " + !!value.capture + ");");
                    }
                  } else {
                    _localEvents.push(CAMEL_OF_EVENTS_DICTIONARY[attribute.name] + (value.capture ? 'Capture' : '') + '=this.' + FUNCTION_NAME + '.bind(this)');
                  }
                }
              } else {
                if (['required', 'disabled', 'readonly'].indexOf(attribute.name) == -1) {
                  _props.push(attribute.name.replace('internal-fsb-ratio-fit', 'internalFsbRatioFit').replace('internal-fsb-ratio-expand', 'internalFsbRatioExpand') + '=' + ((attribute.value[0] == '{') ? attribute.value.replace(/(^{|}$)/g, '') : '"' + attribute.value.split('"').join('&quot;') + '"'));
                } else {
                  _props.push(attribute.name + '=' + ((attribute.value[0] == '{') ? attribute.value.replace(/(^{|}$)/g, '') : attribute.value));
                }
                
                if (isPopup || INHERITING_COMPONENT_RESERVED_ATTRIBUTE_NAMES.indexOf(attribute.name) != -1) {
                  inheritingAttributes.push("'" + attribute.name + "': " + ((attribute.value[0] == '{') ? attribute.value.replace(/(^{|}$)/g, '') : "'" + attribute.value.split('"').join('&quot;') + "'"));
                }
              }
              break;
          }
        }
        
        // In case of no attribute "style":
        //
        if (element.getAttribute('style') === '-fsb-empty' || element.parentNode.getAttribute('style') === '-fsb-empty') {
          isForChildren = true;
        }
        
        if (submitControls) {
          let splited = submitControls && submitControls.split(' ') || [];
          splited = splited.filter(submitControl => !!HTMLHelper.getElementByAttributeNameAndValue('internal-fsb-guid', submitControl, body));
          
	        if (manipulateInto) manipulateInto = '() => { return eval("\\"' + manipulateInto.replace(/\[([^0-9\[\]]+)\]/g, '[\\" + ($1) + \\"]') + '\\""); }';
	        else manipulateInto = '() => { return null; }';
          
          executions.push(`    DataManipulationHelper.register(${JSON.stringify(reactClassComposingInfoGUID)}, ${JSON.stringify(submitType)}, ${JSON.stringify(splited)}, {initClass: ${JSON.stringify(reactClassForPopup)}, submitCrossType: ${JSON.stringify(submitCrossType)}, enabledRealTimeUpdate: ${JSON.stringify(realTimeUpdate === 'true')}, manipulateInto: ${manipulateInto}});`);
          
          let notation = cumulatedDotNotation.split('[')[0];
          let minimumNumberOfDots = Number.MAX_SAFE_INTEGER;
          let assigned = false;
          
          for (let submitControl of splited) {
            let control = HTMLHelper.getElementByAttributeNameAndValue('internal-fsb-guid', submitControl, body);
            if (control) {
              let dataSourceName = HTMLHelper.getAttribute(control, 'internal-fsb-data-source-name');
              if (dataSourceName) {
                let numberOfDots = dataSourceName.split('.').length - 1;
                if (numberOfDots < minimumNumberOfDots) {
                  minimumNumberOfDots = numberOfDots;
                  notation = dataSourceName.split('.')[0];
                }
                if (!assigned) 
                {
                  notation = dataSourceName.split('.')[0];
                  assigned = true;
                }
              }
            }
          }
          
          attributes.push(`onClick=((event) => { window.internalFsbSubmit('${reactClassComposingInfoGUID}', '${notation}', event, ((results) => { this.manipulate('${reactClassComposingInfoGUID}', '${notation}', results); }).bind(this)); }).bind(this)`);
        } else if (reactClassForPopup) {
        	attributes.push(`onClick=((event) => { window.internalFsbOpen('${reactClassForPopup}', this.state.data || this.props.data); }).bind(this)`);
        }
        
        for (let key in bindingStyles) {
          if (bindingStyles.hasOwnProperty(key)) {
            if (styles == null) styles = [];
            let camelKey = key.replace(/\-([a-z])/g, (matched) => { return matched[1].toUpperCase(); });
            styles.push(camelKey + ': ' + bindingStyles[key]);
          }
        }
        
        if (isForChildren && classes.indexOf('internal-fsb-element') != -1) {
          classes = CodeHelper.getInternalClasses(classes);
          attributes.push(`internal-fsb-forward="1"`);
          reactData = null;
        } else if (isForChildren) {
          reactID = HTMLHelper.getAttribute(element.parentNode, 'internal-fsb-react-id');
          reactData = HTMLHelper.getAttribute(element.parentNode, 'internal-fsb-react-data') || null;
        }
        
        if (FORWARD_PROPS_AND_EVENTS_TO_CHILDREN_CLASS_LIST.indexOf(reactClassComposingInfoClassName) != -1) {
        	_forwardAttributes = [..._props, ..._localEvents];
        } else {
        	attributes = [...attributes, ..._props, ..._localEvents];
        	_forwardAttributes = [];
        }
        
        if (_globalEvents.length != 0) executions.push(`    ${_globalEvents.join('\n    ')}`);
        
        if (!reactNamespace) {
          reactNamespace = 'Project.Controls';
        }
        
        if (!reactClass && reactClassComposingInfoClassName && reactClassComposingInfoGUID) {
          reactClass = reactClassComposingInfoClassName + '_' + reactClassComposingInfoGUID;
        }
        
        if (reactMode == 'Site' && isFirstElement) {
          if (classes) classes = classes.replace(ALL_RESPONSIVE_SIZE_REGEX, '').replace(ALL_RESPONSIVE_OFFSET_REGEX, '').trim().replace(/[\ ]+/g, ' ');
          if (!isPopup && styles) styles = styles.filter(style => INHERITING_COMPONENT_RESERVED_STYLE_NAMES_IN_CAMEL.indexOf(style.split("':")[0].split("'")[1]) == -1);
        }
        
        if (!inheritingID && WorkspaceHelper.getComponentData(reactClassComposingInfoGUID)) {
          inheritingID = reactClassComposingInfoGUID;
        }
        
        if (inheritingID) {
          let componentInfo = WorkspaceHelper.getComponentData(inheritingID);
          if (componentInfo) {
            reactMode = 'Inheriting';
            reactNamespace = componentInfo.namespace;
            reactClass = componentInfo.klass;
            
            inheritingAttributes.push("'styles': {" + inheritingStyles.join(', ') + "}");
          } else {
            inheritingID = null;
          }
        }
        
        if (isFirstElement) {
          reactData = null;
          attributes = attributes.filter(token => token.indexOf('internal-fsb-class') == 0);
        } else if (reactMode) {
          attributes = attributes.filter(token => token.indexOf('internal-fsb-class') != 0);
        }
        
        // For react rendering method:
        // 
        if (reactID && (!isForChildren || classes.indexOf('internal-fsb-element') == -1)) {
          attributes.splice(0, 0, 'ref="' + reactID + '"');
        }
        
        // Dot Notation Feature
        // 
        if (reactAccumulateNotation == 'reset') cumulatedDotNotation = '';
        if (reactData) reactData = reactData.replace(/\[([^0-9\[\]]+)\]/g, '[" + ($1) + "]');
        
        let _indent = indent;
        let _leafNode = FrontEndDOMHelper.isNotationLeafNode(cumulatedDotNotation + reactData);
        let _nodeData = 'data';
        if (reactData !== null) {
          if (!_leafNode) {
            lines.push(indent + 'each data, ' + dotNotationChar + ' in this.getDataFromNotation("' + cumulatedDotNotation + reactData + '", true, ' + (reactDisplayLogic == 'always') + ')');
            
            indent += '  ';
            
            cumulatedDotNotation += (!cumulatedDotNotation || cumulatedDotNotation.endsWith('.') ? '' : '.') + reactData + '[" + ' + dotNotationChar + ' + "].';
          } else {
            _nodeData = 'this.getDataFromNotation("' + cumulatedDotNotation + reactData + '")';
            
            cumulatedDotNotation += (!cumulatedDotNotation || cumulatedDotNotation.endsWith('.') ? '' : '.') + reactData + '.';
          }
        }
        
        // Rendering Logic
        // 
        if (reactDisplayLogic == 'statement' && (!reactMode || isFirstElement)) {
        	lines.push(`${indent}if ${reactDisplayStatement || 'true'}`);
        	indent += '  ';
        }
        
        // Include Another React Class Feature
        // 
        if (reactMode && !isFirstElement) {
        	const namespace = reactNamespace + '.' + reactClass;
          
          if (context[namespace] === undefined) context[namespace] = 0;
          else context[namespace]++;
          
          let composed = indent;
          composed += `- const ${(namespace).split('.').join('_')}_${context[namespace]}_ = ${namespace};`
          lines.push(composed);
          
          let _attributes = _props || [];
          if (reactData) _attributes.push('key="item_" + (data && data.keys && Object.keys(data.keys).map((key)=>{return key + ":" + data.keys[key];}).join("_") || ' + dotNotationChar + ')' + ((reactFieldDivision !== 'flatten') ? ', data-fsb-index=' + ((reactFieldDivision == 'statement') ? (reactFieldDivisionStatement || '0') : dotNotationChar) : ''));
          if (reactID && !reactData) _attributes.push('ref="' + reactID + '" ');
          if (reactID && reactData) _attributes.push('ref="' + reactID + '[" + ' + dotNotationChar + ' + "]"');
          if (reactData) _attributes.push('row=' + _nodeData);
          if (inheritingID) _attributes.push(`forward={${inheritingAttributes.join(', ')}}`);
          
          _attributes = Array.from(new Set(_attributes));
          
          composed = indent;
          composed += '_' + (namespace).split('.').join('_') + '_' + context[namespace] + '_(' + _attributes.join(', ') + ')';
          lines.push(composed);
        }
        
        // Dot Notation Feature (Continue 1/2)
        // 
        if (reactData && !_leafNode) {
          attributes.splice(0, 0, 'key="item_" + (data && data.keys && Object.keys(data.keys).map((key)=>{return key + ":" + data.keys[key];}).join("_") || ' + dotNotationChar + ')' + ((reactFieldDivision !== 'flatten') ? ', data-fsb-index=' + ((reactFieldDivision == 'statement') ? (reactFieldDivisionStatement || '0') : dotNotationChar) : ''));
        }
        
        if (reactData !== null || (reactMode && !isFirstElement)) {
          if (!_leafNode) {
            let charcode = dotNotationChar.charCodeAt() + 1;
            dotNotationChar = String.fromCharCode(charcode);
          }
        }
        
        // Recursive Children Feature
        //
        if (!reactMode || isFirstElement) {
          let composed = indent;
          let children = [...element.childNodes];
          
          children = children.filter(element => [Accessories.cursor.getDOMNode(), Accessories.resizer.getDOMNode(), Accessories.guide.getDOMNode()].indexOf(element) == -1 && (!!element.tagName || element.textContent.trim() != ''));
          
          if (tag === 'div') {
            if (classes == '') composed += tag;
          } else {
            composed += tag;
          }
          
          if (classes != '') {
            if (!isFirstElement) composed += '.' + TextHelper.removeExtraWhitespaces(classes).split(' ').join('.');
            else {
              attributes.push('className="' + classes + ' " + (this.props.forward && this.props.forward.classes || \'\')');
            }
          }
          if (reactClassComposingInfoGUID != null) attributes.push('internal-fsb-guid="' + reactClassComposingInfoGUID + '"');
          if (styles != null) {
            if (!isFirstElement) attributes.splice(0, 0, 'style={' + styles.join(', ') + '}');
            else attributes.splice(0, 0, 'style=Object.assign({' + styles.join(', ') + '}, this.props.forward && this.props.forward.styles || {})');
          } else if (isFirstElement) {
            attributes.splice(0, 0, 'style=Object.assign({}, this.props.forward && this.props.forward.styles || {})');
          }
          if (composed == indent) composed += 'div';
          
          attributes = Array.from(new Set(attributes));
          
          if (attributes.length != 0) composed += '(' + attributes.join(', ').replace(/___DATA___/g, _nodeData) + ')';
          
          if (!dangerouslySetInnerHTML) {
            lines.push(composed);
            
            for (let child of children) {
              FrontEndDOMHelper.recursiveGenerateCodeForReactRenderMethod(body, child, indent + '  ', executions, lines, false, cumulatedDotNotation, dotNotationChar, _forwardAttributes, (reactMode && !isFirstElement) ? {} : context);
            }
          } else {
            lines.push(composed);
          }
        }
      }
    }
  },
  recursiveGenerateCodeForFallbackRendering: function(body: HTMLElement, element: HTMLElement, indent: string, executions: string[], lines: string[], isFirstElement: boolean=true) {
    if (HTMLHelper.hasClass(element, 'internal-fsb-accessory')) return;
    if (HTMLHelper.hasClass(element, 'internal-fsb-plug')) return;
    
    if (element) {
      if (!element.tagName) {
        if (element.textContent.trim() != '') {
        	if (['style', 'script'].indexOf(element.parentNode.tagName && element.parentNode.tagName.toLowerCase() || null) != -1) {
        		lines[lines.length - 1] += '.';
        		lines.push(indent + element.textContent.split('\n').join('\n' + indent));
        	} else {
        		let textContent = element.textContent;
        		textContent = textContent.replace(/(\#)?\{([A-Za-z0-9_]+(\.[A-Za-z0-9_])*)\}/g, (match, hash, suffix) => {
        			return (hash == null) ? `\#{this.getDataFromNotation("${cumulatedDotNotation}${suffix}")}` : match;
        		});
        		
          	lines.push(indent + '| ' + textContent.split('\n').join('\n' + indent + '| '));
          }
        }
      } else {
        let tag = element.tagName.toLowerCase().replace('ruffle-embed', 'embed');
        let _attributes = HTMLHelper.getAttributes(element, true, {}, false);
        let classes = '';
        let styles = null;
        let bindingStyles = {};
        let _globalEvents = [];
        let _localEvents = [];
        let attributes = [];
        let isForChildren = false;
        let isReactElement = false;
        let reactMode = null;
        let reactCommand = null;
        let reactNamespace = null;
        let reactClass = null;
        let reactClassComposingInfoClassName = null;
        let reactClassComposingInfoGUID = null;
        let reactClassForPopup = null;
        let inheritingID = null;
        let inheritingAttributes = [];
        let inheritingStyles = [];
        let submitControls = null;
        let submitType = null;
        let submitCrossType = null;
        let activeAnimation = null;
        
        for (let attribute of _attributes) {
          if (attribute.name.indexOf('internal-fsb-react-style-') == 0 && attribute.value) {
            let bindingName = attribute.name.replace('internal-fsb-react-style-', '');
            let bindingType = attribute.value.split('[')[0];
            let bindingValue = attribute.value.match(/^[A-Z]+\[(.+)\]$/)[1];
            
            if (bindingName === 'background-color') {
              attribute.name = 'internal-fsb-react-style-background-color';
              bindingName = 'background';
            }
            
            switch (bindingType) {
              case 'SETTING':
                bindingStyles[bindingName] = 'Project.Settings.' + bindingValue;
                break;
              case 'PROPERTY':
                bindingStyles[bindingName] = 'this.props.' + bindingValue;
                break;
              case 'STATE':
                bindingStyles[bindingName] = 'this.state.' + bindingValue;
                break;
              case 'CODE':
                bindingStyles[bindingName] = '(()=>{' + bindingValue + '})()';
                break;
            }
          }
        }
        
        if (FORWARD_STYLE_TO_CHILDREN_CLASS_LIST.indexOf(HTMLHelper.getAttribute(element, 'internal-fsb-class')) != -1) {
        	bindingStyles = {}; // Disable custom binding.
          bindingStyles['padding'] = bindingStyles['padding'] || "'0px'";
        }
        
        for (let attribute of _attributes) {
        	if (attribute.value === null) continue;
        	
        	attribute.name = CodeHelper.replaceDashIntoCamelCase(attribute.name);
        	
          switch (attribute.name) {
            case 'class':
              classes = attribute.value.replace('internal-fsb-selecting', '').replace('internal-fsb-walking', '').replace('internal-fsb-allow-cursor', '').trim();
              
              let sizeMatches = attribute.value.match(ALL_RESPONSIVE_SIZE_REGEX) || [];
              let offsetMatches = attribute.value.match(ALL_RESPONSIVE_OFFSET_REGEX) || [];
              
              inheritingAttributes.push("'classes': '" + [...sizeMatches, ...offsetMatches].join(' ') + "'");
              break;
            case 'style':
              attribute.value = element.getAttribute('style');
              if (attribute.value == '-fsb-empty') {
                continue;
              }
              let hashMap = HTMLHelper.getHashMapFromInlineStyle(attribute.value);
              for (let key in hashMap) {
                if (hashMap.hasOwnProperty(key)) {
                  if (styles == null) styles = [];
                  if (key.indexOf('-fsb-cell') == 0) continue;
                  if (key.indexOf('-fsb-for-children') == 0 && hashMap[key] == 'true') {
                    continue;
                  }
                  let token = "'" + key + "': '" + hashMap[key] + "'";
                  styles.push(token);
                
                  if (INHERITING_COMPONENT_RESERVED_STYLE_NAMES.indexOf(key) != -1) {
                    inheritingStyles.push(token);
                  }
                }
              }
              break;
            case 'internal-fsb-react-mode':
              if (!!attribute.value) reactMode = attribute.value;
              break;
            case 'internal-fsb-react-command':
              if (!!attribute.value) reactCommand = attribute.value;
              break;
            case 'internal-fsb-react-namespace':
              if (!!attribute.value) reactNamespace = attribute.value;
              break;
            case 'internal-fsb-react-class':
              if (!!attribute.value) reactClass = attribute.value;
              break;
            case 'internal-fsb-data-controls':
              if (!!attribute.value) submitControls = attribute.value.trim();
              break;
            case 'internal-fsb-data-wizard-type':
              if (!!attribute.value) submitType = attribute.value;
              break;
            case 'internal-fsb-data-wizard-cross-operation':
              if (!!attribute.value) submitCrossType = attribute.value;
              break;
            case 'internal-fsb-class':
              if (!!attribute.value) reactClassComposingInfoClassName = attribute.value;
              if (['FlowLayout'].indexOf(attribute.value) != -1) attributes.push('internal-fsb-class="' + attribute.value + '"');
              break;
            case 'internal-fsb-guid':
              if (!!attribute.value) reactClassComposingInfoGUID = attribute.value;
              break;
            case 'internal-fsb-popup-init-class':
              if (!!attribute.value) reactClassForPopup = attribute.value;
              break;
            case 'internal-fsb-inheriting':
              if (!!attribute.value) inheritingID = attribute.value;
              break;
            case 'contenteditable':
              continue;
            default:
              if (attribute.name.indexOf('internal-fsb-') == 0 && ['internal-fsb-animation', 'internal-fsb-ratio-fit', 'internal-fsb-ratio-expand'].indexOf(attribute.name) == -1) continue;
              if (CAMEL_OF_EVENTS_DICTIONARY[attribute.name]) {
                let value = null;
                if (attribute.value) value = JSON.parse(attribute.value);
                else value = {};
                
                if (value.event) {
                  let FUNCTION_NAME = CAMEL_OF_EVENTS_DICTIONARY[attribute.name].replace(/^on/, 'on' + HTMLHelper.getAttribute(element, 'internal-fsb-class')) + '_' + HTMLHelper.getAttribute(element, 'internal-fsb-guid');
                  
                  if (ALL_DOCUMENT_SUPPORT_OF_CAMEL_OF_EVENTS.indexOf(attribute.name) != -1) {
                  	if (attribute.name == 'onfsbready') {
                  		_globalEvents.push("ready(controller." + FUNCTION_NAME + ".bind(controller));");
                  	} else {
                  		_globalEvents.push("document.addEventListener('" + CAMEL_OF_EVENTS_DICTIONARY[attribute.name].replace(/^on(Document)?/, '').toLowerCase() + "', controller." + FUNCTION_NAME + ".bind(controller), " + !!value.capture + ");");
                  	}
                  } else {
                    _localEvents.push([CAMEL_OF_EVENTS_DICTIONARY[attribute.name].replace(/^on/, '').toLowerCase(), FUNCTION_NAME, !!value.capture]);
                  }
                }
              } else {
                attributes.push(attribute.name + '=' + ((attribute.value[0] == '{') ? attribute.value.replace(/(^{|}$)/g, '') : '"' + attribute.value.split('"').join('&quot;') + '"'));
                
                if (INHERITING_COMPONENT_RESERVED_ATTRIBUTE_NAMES.indexOf(attribute.name) != -1) {
                  inheritingAttributes.push("'" + attribute.name + "': " + ((attribute.value[0] == '{') ? attribute.value.replace(/(^{|}$)/g, '') : "'" + attribute.value.split('"').join('&quot;') + "'"));
                }
              }
              break;
          }
        }
        
        // In case of no attribute "style":
        //
        if (element.getAttribute('style') === '-fsb-empty' || element.parentNode.getAttribute('style') === '-fsb-empty') {
          isForChildren = true;
        }
        
        if (submitControls) {
        	let splited = submitControls && submitControls.split(' ') || [];
        	splited = splited.filter(submitControl => !!HTMLHelper.getElementByAttributeNameAndValue('internal-fsb-guid', submitControl, body));
        	
          executions.push(`DataManipulationHelper.register(${JSON.stringify(reactClassComposingInfoGUID)}, ${JSON.stringify(submitType)}, ${JSON.stringify(splited)}, {initClass: ${JSON.stringify(reactClassForPopup)}, submitCrossType: ${JSON.stringify(submitCrossType)}, enabledRealTimeUpdate: false}});`);
          
          attributes.push(`onClick="internalFsbSubmit('${reactClassComposingInfoGUID}', null, event, null)"`);
        } else if (reactClassForPopup) {
        	attributes.push(`onClick="internalFsbOpen('${reactClassForPopup}')"`);
        }
        
        for (let key in bindingStyles) {
          if (bindingStyles.hasOwnProperty(key)) {
            if (styles == null) styles = [];
            let camelKey = key.replace(/\-([a-z])/g, (matched) => { return matched[1].toUpperCase(); });
            styles.push(camelKey + ': ' + bindingStyles[key]);
          }
        }
        
        if (isForChildren && classes.indexOf('internal-fsb-element') != -1) {
          classes = CodeHelper.getInternalClasses(classes);
          attributes.push(`internal-fsb-forward="1"`);
        }
        
        if (_globalEvents.length != 0) executions.push(_globalEvents.join('\n'));
        
        if (!reactNamespace) {
          reactNamespace = 'Project.Controls';
        }
        
        if (!reactClass && reactClassComposingInfoClassName && reactClassComposingInfoGUID) {
          reactClass = reactClassComposingInfoClassName + '_' + reactClassComposingInfoGUID;
        }
        
        if (reactMode == 'Site' && isFirstElement) {
          if (classes) classes = classes.replace(ALL_RESPONSIVE_SIZE_REGEX, '').replace(ALL_RESPONSIVE_OFFSET_REGEX, '').trim().replace(/[\ ]+/g, ' ');
          if (styles) styles = styles.filter(style => INHERITING_COMPONENT_RESERVED_STYLE_NAMES_IN_CAMEL.indexOf(style.split("':")[0].split("'")[1]) == -1);
        }
        
        if (!inheritingID && WorkspaceHelper.getComponentData(reactClassComposingInfoGUID)) {
          inheritingID = reactClassComposingInfoGUID;
        }
        
        if (inheritingID) {
          let componentInfo = WorkspaceHelper.getComponentData(inheritingID);
          if (componentInfo) {
            reactMode = 'Inheriting';
            reactNamespace = componentInfo.namespace;
            reactClass = componentInfo.klass;
            
            inheritingAttributes.push("'styles': {" + inheritingStyles.join(', ') + "}");
          } else {
            inheritingID = null;
          }
        }
        
        // For HTML5 fallback rendering:
        // TODO: still skip dot notation in fallback mode.
        // 
        
        // Include Another React Class Feature
        // 
        if (reactMode && !isFirstElement) {
          lines.push(indent + 'span(internal-fsb-init-class="' + reactNamespace + '.' + reactClass + '"' + (inheritingID ?' internal-fsb-init-forward="{' + inheritingAttributes.join(', ') + '}"' : '') + ')');
        }
        
        // Recursive Children Feature
        //
        if (!reactMode || isFirstElement) {
          let composed = indent;
          let children = [...element.childNodes];
          
          children = children.filter(element => [Accessories.cursor.getDOMNode(), Accessories.resizer.getDOMNode(), Accessories.guide.getDOMNode()].indexOf(element) == -1);
          
          if (tag === 'div') {
            if (classes == '') composed += tag;
          } else {
            composed += tag;
          }
          
          if (classes != '') composed += '.' + TextHelper.removeExtraWhitespaces(classes).split(' ').join('.');
          if (reactClassComposingInfoGUID != null) attributes.push('internal-fsb-guid="' + reactClassComposingInfoGUID + '"');
          if (styles != null) attributes.splice(0, 0, 'style={' + styles.join(', ') + '}');
          if (composed == indent) composed += 'div';
          
          attributes = Array.from(new Set(attributes));
          
          if (attributes.length != 0) composed += '(' + attributes.join(', ') + ')';
          
          lines.push(composed);
          
          if (_localEvents.length != 0) {
            executions.push(`controller.listen('${reactClassComposingInfoGUID}');`);
          }
          
          for (let child of children) {
            FrontEndDOMHelper.recursiveGenerateCodeForFallbackRendering(body, child, indent + '  ', executions, lines, false);
          }
        }
      }
    }
  },
  generateCodeForMergingSection: function(body: HTMLElement, element: HTMLElement) {
    let executions: string[] = [];
    let lines: string[] = [];
    FrontEndDOMHelper.recursiveGenerateCodeForMergingSection(body, element, executions, lines, true, EditorHelper.hasParentReactComponent(element));
    
    return [executions.join('\n'), lines.join('\n')];
  },
  recursiveGenerateCodeForMergingSection: function(body: HTMLElement, element: HTMLElement, executions: string[], lines: string[], isFirstElement: boolean=true, hasParentReactComponent: boolean=true) {
    if (HTMLHelper.hasClass(element, 'internal-fsb-accessory')) return;
    
    if (element && element.tagName) {
      if (!isFirstElement && HTMLHelper.getAttribute(element, 'internal-fsb-react-mode')) return;
      
      if (!isFirstElement) {
        let reusablePresetName = HTMLHelper.getAttribute(element, 'internal-fsb-reusable-preset-name') || null;
        let presetId = HTMLHelper.getAttribute(element, 'internal-fsb-guid');
        let attributes = null;
        
        if (reusablePresetName) {
          attributes = HTMLHelper.getAttributes(element, false, {
            style: StylesheetHelper.getStylesheetDefinition(presetId)
          });
        } else {
          attributes = HTMLHelper.getAttributes(element, false);
        }
        
        let code, mapping;
        [code, mapping] = FrontEndReactHelper.generateMergingCode(attributes, hasParentReactComponent ? null : executions, true);
        
        if (code) lines.push(code);
      }
      
      let children = [...element.childNodes];
      for (let child of children) {
        FrontEndDOMHelper.recursiveGenerateCodeForMergingSection(body, child, executions, lines, false, hasParentReactComponent);
      }
    }
  },
  getDataTableSchemaFromKey: (key: string, current: any, data: any): any => {
    const relation = (current && current.relations || {})[key];
    const table = (data.tables || {})[key];
    
    if (relation) {
      return (data.tables || {})[relation.targetGroup] || null;
    } else if (table) {
      return table;
    } else {
      return null;
    }
  },
  isNotationLeafNode: (notation: string): boolean => {
    const data = {
      tables: WorkspaceHelper.getDataFlows()
    }
    
    const splited = notation.replace(/\[[^\[\]]*\]/g, '').split(".");
    let shifted: string = splited.shift();
    let current: any = null;
    
    do {
      current = FrontEndDOMHelper.getDataTableSchemaFromKey(shifted, current, data);
      shifted = splited.shift();
    } while (current && shifted);
    
    return (current == null);
  },
  generateImageDataURLWithRatio: (width: number, height: number): string => {
  	const canvas = document.createElement("canvas");
		canvas.width = width;
		canvas.height = height;
		return canvas.toDataURL();
  }
};

export {FrontEndDOMHelper};